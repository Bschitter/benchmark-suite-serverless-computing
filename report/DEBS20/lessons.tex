%!TEX root = main.tex

\section{Lessons Learned}\label{sec:lessons}
This thesis has shown that serverless computing in the form of \gls{FaaS} can deliver good performance at a reasonable price. For the end user it is fairly simple to start with, to use and maintain compared to \gls{VM}s or even physical servers. With serverless, companies can focus on building their business logic instead of maintaining operating systems and servers which requires expertise and is especially for smaller companies not always affordable. The probably most important point is auto scaling. If the serverless platform can handle that well it takes away one big crucial factor the user does not longer have to care about. Today there are other solutions for automatically scaling applications (i.e. Kubernetes cluster) but using a serverless platform is definitely simpler and more comfortable.\\
Nevertheless, there are also 

Through the implementation and evaluation of \sys, we encounted the following limitations of the FaaS paradigm. 

First, one is heavily limited by the offering of a specific cloud provider, including
available runtimes and programming languages, supported triggers, the possibility of third party 
services integration, quotas, maximum memory. 
Users cannot easily overcome such limitations, although given the full application stack is managed by the provider, it might only rarely result in considerable limitations.

Second, providers can force (\eg flipping an upgrade switch) an application to migrate from a specific runtime version to an arbitrarely differentone (\eg from Node.js v6 to v8).
Despite backward compatibility, functions might break, forcing developers to keep up the peace imposed by the cloud provider.

Thirdly, developers risk to vendor-lock themselves, even unintentionally.
Especially when application upgrades and potential provider migrations are considered, this might become a serious issue.

Lack of deployment standards makes the FaaS paradigm still a largely experimental playground.
Providers offer custom APIs (\eg request/response objects), which inevitably vary across cloud offerings.
A common framework supported by a standard would certainly improve adoption and benefit the whole ecosystem.


%can normally not be changed or influenced by the user. In most cases and particularly for simpler applications this should be no obstacle. 
%Considering the full development stack is managed by the provider users can potentially be forced to upgrade their application runtime (e.g. Node.js 6 to Node.js 8) when it reaches end of life. If this is announced early enough it doesn't put the users under pressure. But still the action eventually needs to be done and this costs resources. That can be annoying and the user has no control over it.\\

%Another risk of using these services can be a vendor lock-in. If the service is easily capable of being integrated along with other services of the cloud, the user can be entrapped to use them and get unintentionally bonded to the provider. 
%When a change in the application design is on its way or even a change of the cloud provider is considered, these integrations could block a modification in the architecture or a migration.\\

%Furthermore there is no de facto standard on how to implement and deploy the functions. Each cloud uses its custom methods and properties (e.g. request and response object) inside the function which varies across the clouds. There is obviously no common interest of the providers to develop a standardized framework due to their competition.\\
%A last aspect I'd like to mention is efficiency. Since the customer is billed by the execution time of the function it is extremely important to only run highly optimized and efficient code, when executed in high quantities. Otherwise billing for unnecessary or idle \gls{CPU} time (e.g. run remote operations synchronously) can happen. This concern should be obvious to developers and entrepreneurs but the fact that one is billed exactly by the usage emphasizes it even more (compared of having an over provisioned server).